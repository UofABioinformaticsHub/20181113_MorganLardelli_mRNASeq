---
title: "*psen2* 3-genotype RNA-seq analysis "
author: "Karissa "
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    code_folding: hide
    toc_depth: 3
    fig_caption: yes
    toc_float: true
    fig_height: 8
    fig_width: 8
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Setup

```{r loadPackages}
library(limma)
library(edgeR)
library(tximport)
library(AnnotationHub)
library(magrittr)
library(scales)
library(tidyverse)
library(ggrepel)
library(RColorBrewer)
library(fgsea)
library(msigdbr)
library(pander)
library(kableExtra)
library(ggfortify)
library(ggpubr)
library(pheatmap)
library(here)
library(goseq)
library(RUVSeq)
library(harmonicmeanp)
library(ngsReports)
library(UpSetR)
library(gridExtra)
```

```{r otherOptions}
if (interactive()) setwd(here("R"))
panderOptions("table.split.table", Inf)
theme_set(theme_bw())
```

The alignments in this analysis were generated by Steve. He aligned each library (including technical replicates) to the Zebrafish transcriptome from Ensembl Release 94 (GRCz11) using kallisto (v0.43.1).
In addition to the standard transcriptome, the two mutant *psen2* transcripts were manually added to the reference.

The corresponding set of gene descriptions were then loaded into `R` as an `EnsDb` object using the `AnnotationHub()` infrastructure.
Likewise, the set of transcript descriptions were loaded, with the manual addition of the two novel *psen2* mutants.

## annotation objects

```{r genes}
ah <- AnnotationHub() %>%
	subset(species == "Danio rerio") %>%
	subset(rdataclass == "EnsDb")
ensDb <- ah[["AH64906"]]
genes <- genes(ensDb) 
mcols(genes) <- mcols(genes)[!names(mcols(genes)) %in% c("seq_coord_system", "gene_name")]
```

```{r transcripts}
transcripts <- transcripts(ensDb)
psen2 <- subset(transcripts, gene_id == "ENSDARG00000015540") %>% 
	granges() %>% 
	magrittr::extract(c(1, 1),) 
names(psen2) <- c("psen2T141_L142delinsMISLISV", "psen2N140fs")
mcols(psen2) <- DataFrame(tx_id = names(psen2),
													tx_biotype = c("protein_coding", "nonsense_mediated_decay"),
													gene_id = "ENSDARG00000015540",
													tx_id_version = names(psen2),
													tx_name = names(psen2))
transcripts %<>%
	GRangesList(psen2) %>%
	unlist() %>%
	sort()

transcripts$symbol <- mcols(genes[transcripts$gene_id])$symbol
# tx2gene <- mcols(transcripts)[c("tx_id_version", "gene_id")] 
tx2gene <- mcols(transcripts)[c("tx_id_version", "symbol")] %>%
	subset(symbol != "")

geneCounts <- list.files(path = here("3_kallisto"), recursive = TRUE, pattern = "h5", full.names = TRUE) %>%
	set_names(basename(dirname(.))) %>%
	set_names(str_replace(names(.), "_-", "WT")) %>%
	tximport(type = "kallisto", tx2gene = tx2gene)
```

# genotype checks

Transcript-level counts were imported using `catchKallisto()` from `edgeR` in order to check that expression of the *psen2* alleles matches the genotype of the fish which was determined by PCRs performed on genomic DNA from each fish extracted from their tail. 

From the plot below, we see that fish `8_FS_4` is actually a transheterozygous fish and should be omitted. 

```{r, fig.height=4, fig.cap = "*CPM values for each psen2 transcript across all samples.*", warning=FALSE, message=FALSE, results='hide'}
transCounts <- list.files(here("3_kallisto/"), full.names = TRUE) %>%
	catchKallisto()

colnames(transCounts$counts) %<>%
	basename() %>%
	str_replace("_-", "WT")


psen2IDs <- subset(transcripts, symbol == "psen2") %>% names()

transCounts$counts %>%
	cpm() %>% 
	set_rownames(str_remove(rownames(.), "\\.[0-9]+")) %>%
	magrittr::extract(psen2IDs,) %>%
	as.data.frame() %>%
	rownames_to_column("Transcript") %>%
	gather(key = "Sample", value = "CPM", -Transcript) %>%
	mutate(Transcript = str_replace(Transcript, "ENSDART.+", "psen2-WT"), 
				 Genotype = str_extract(Sample, "(WT|FAD|FS)")) %>% 
	ggplot(aes(Sample, CPM, fill = Transcript)) +
	geom_bar(stat = "identity", colour = "black") +
	facet_wrap(~Genotype, nrow = 1, scales = "free_x") +
	scale_fill_viridis_d(option = "viridis") +
	theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), 
				aspect.ratio = 1) 
```

# Make the DGE object

```{r}
minCpm <- 1
minSamples <- 5
dge <- geneCounts$counts %>%
	magrittr::extract(rowSums(cpm(.) > minCpm) >= minSamples,) %>%
	DGEList() %>%
	calcNormFactors()

dge$samples %<>%
	mutate(Sample = rownames(.),
				 Genotype = str_extract(Sample, "(WT|FAD|FS)"),
				 Genotype = factor(Genotype, levels = c("WT", "FS", "FAD")),
				 group = as.integer(Genotype), 
				 Genotype_forPub = case_when(
				 	Genotype == "FAD" ~ "EOfAD", 
				 	Genotype == "FS" ~ "FS" , 
				 	TRUE ~ "WT"
				 ),
				 Genotype_forPub = factor(Genotype_forPub, levels = c("WT", "FS", "EOfAD", "transhet"))) %>%
	set_rownames(.$Sample)

dge$samples["8_FS_4",]$Genotype_forPub <- "transhet"

dge$samples %<>%   
	mutate(Sex = case_when(
				 Sample %in% c("15_WT_1", 
				 							"14_WT_2",  
				 							"13_WT_3", 
				 							"10_FS_1", 
				 							"5_FS_2", 
				 							"9_FS_3",  
				 							"6_FAD_1",
				 							"4_FAD_2",
				 							"3_FAD_3") ~ "Female" ,
				 TRUE ~ "Male")) %>% 
	set_rownames(.$Sample)

```
Gene-level counts were imported using `tximport`, mapping transcripts to genes.
Some genes exist in the primary assembly and on alternate assemblies for specific regions, and these were considered as separate transcripts of the same gene for read summarisation purposes. 
Transcript counts were thus mapped to genes using the gene symbol (e.g. *psen2*), instead of the gene id.

Upon loading into a DGE object, genes which had less than `r minCpm`	in at least `r minSamples` of the samples were omitted. This equated to about `r floor(mean(minCpm*dge$samples$lib.size/1e6))` reads for a gene in at least `r minSamples` samples for inclusion in downstream analysis, giving a total of `r comma(nrow(dge))` of the original `r comma(nrow(counts))` genes for DGE analysis.

# library sizes
```{r, echo=FALSE, fig.cap="*Total counts from each library after assigning to genes*", fig.height=4}
dge$samples %>% 
	ggplot(aes(Sample, lib.size, fill = Genotype)) +
	geom_bar(stat = "identity") +
	scale_y_continuous(labels = comma, expand = expansion(c(0, 0.05))) +
	facet_wrap(~Genotype, scales = "free_x") +
	labs(y = "Library Size") +
	theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
	scale_fill_manual(values = c("grey30", "firebrick", "darkcyan" ))

```

# PCA on entire dataset

I next will perform a Principal Component Analysis to visualise the similarity between samples. Note that sample `12_WT_4` appears quite distant from the others. No clear seperation is observed of genotypes or sex. Also PC1 and PC2 only account for ~30% of the total vriation in this dataset, which is lower than one would expect

```{r}
dge %>% 
	cpm(log = TRUE) %>% 
	t() %>% 
	prcomp() %>% 
	autoplot(
		data = tibble(Sample = rownames(.$x)) %>%
			left_join(dge$samples),
		colour = "Genotype_forPub", 
		size = 4, 
		shape = "Sex",
	) +
  geom_label_repel(
    aes(label = Sample, colour = Genotype_forPub), show.legend = FALSE
  ) +
	scale_color_manual(values = c("darkcyan",  "firebrick" , "purple4", "grey30"))
```

# MDS plot

Another way of visualising the similarity between samples is a multi-dimensional scaling plot (MDS) plot. The distances between samples can be interpreted as the leading log2-fold-change, so that similar samples will cluster together. Like in the PCA plot, sample `12_WT_4` appears quite distant from the rest, and no seperation between genotypes or sex is observed. 

```{r}
# save this plot as an object for later. 
mds1 <- dge %>% 
	plotMDS(plot = FALSE) %>%
	extract2("cmdscale.out") %>%
	set_colnames(paste0("Dim", 1:2)) %>% 
	as.data.frame() %>% 
	rownames_to_column("Sample") %>% 
	left_join(dge$samples) %>% 
	ggplot(aes(Dim1, Dim2)) +
	geom_point(aes(colour = Genotype_forPub, shape = Sex), size = 4) +
	labs(x = "Dimension 1", 
			 y = "Dimension 2", 
			 colour = "Genotype") +
	geom_label_repel(aes(label = Sample, colour = Genotype_forPub)) +
	scale_colour_manual(values = c("grey30", "firebrick", "darkcyan", "purple")) +
	theme(aspect.ratio = 1)

mds1
```

# drop samples
I showed before that `8_FS_4` is actually a transhet sample. Therefore, I will omit it from the analysis.
 
In the PCA and MDS plots above, and in the previous `limma` analysis by Steve, sample `12_WT_4` was an obvious outlier as it did not cluster with the rest of the samples, and steve showed it was downweighted majorly compared to the others and will also e omitted.

```{r dge}
dropSamples <- c("8_FS_4", "12_WT_4")

dge <- dge[,!colnames(dge) %in% dropSamples]
```

### MDS plots

the MDS and PCA plots are now regenerated below 
```{r}
dge %>% 
	plotMDS(plot = FALSE) %>%
	extract2("cmdscale.out") %>%
	set_colnames(paste0("Dim", 1:2)) %>% 
	as.data.frame() %>% 
	rownames_to_column("Sample") %>% 
	left_join(dge$samples) %>% 
	ggplot(aes(Dim1, Dim2)) +
	geom_point(aes(colour = Genotype_forPub, shape = Sex), size = 4) +
	#geom_label_repel(aes(label = Sample, colour = Genotype), show.legend = FALSE) +
	theme_bw() +
	labs(x = "Dimension 1", 
			 y = "Dimension 2", 
			 colour = "Genotype") + 
	scale_colour_manual(values = c("grey30", "firebrick", "darkcyan" ))
```

```{r}
dge %>%
	cpm(log = TRUE) %>%
	t() %>%
	prcomp() %>%
	autoplot(
		data = tibble(Sample = rownames(.$x)) %>%
			left_join(dge$samples),
		colour = "Genotype", 
		size = 4, 
		shape = "Sex",
	) +
  geom_label_repel(
    aes(label = Sample, colour = Genotype),
    show.legend = FALSE
  )  +
	scale_colour_manual(values = c("grey30", "firebrick", "darkcyan" ))

dge %>%
	cpm(log = TRUE) %>%
	t() %>%
	prcomp() %>% 
	summary() %>%
	extract2("importance") %>%
	magrittr::extract(,paste0("PC", 1:5)) %>%
	kable(caption = paste("*First five principal components, showing that the first two only account for", percent(.[3,2]), "of the total variance, which is below expectations*")) %>% 
	kable_styling()
```

## Hierarchical clustering

Another visualisation here is performed where samples are clustered based on their Euclidean distance.

```{r}
anno <-
	dge %>% 
  cpm(log = T) %>% 
  t() %>% 
  rownames() %>% 
  as.data.frame() %>% 
  set_colnames("Sample") %>% 
  left_join(dge$samples) %>% 
  dplyr::select(Sample, c(Genotype = Genotype_forPub), Sex) %>% 
  column_to_rownames("Sample")

dge %>% 
  cpm(log = T) %>% 
  t() %>% 
  dist(method = "euclidean") %>% 
  as.matrix() %>% 
  pheatmap(
    color = viridis::viridis_pal(option = "viridis")(100), 
    annotation_col = anno, 
    annotation_colors = list(Genotype = c(FS = "firebrick", 
    																			WT = "grey30", 
    																			EOfAD = "darkcyan"), 
    												 Sex = c(Male = "#FF9700", 
    												 				Female = "#0370FF")),
    show_rownames = F, 
    show_colnames = F, 
    annotation_row = anno, 
    cellwidth = 10, cellheight = 10, 
    treeheight_row = 10, treeheight_col = 10)
```


# DGE analysis using edgeR

Steve previously performed a `limma` analysis. Here, I will perform a DGE analysis using the GLM and likelihood ratio tests of `edgeR`, which in our experience, has more power to detect DE genes. 

```{r}
# model matrix
design <- model.matrix(~Genotype, data = dge$samples) %>% 
	set_colnames(gsub("Genotype", "", colnames(.)))

# fit the glm
fit <- dge %>% 
	estimateDisp(design) %>% 
	glmFit(design)

topTables_glm <- design %>% colnames() %>% .[2:3] %>% 
   sapply(function(x){
    glmLRT(fit, coef = x) %>%
      topTags(n = Inf) %>%
      .[["table"]] %>%
      as.data.frame() %>%
   		rownames_to_column("symbol") %>% 
      arrange(PValue) %>%
       mutate(
        coef = x,
        DE = FDR < 0.05
      ) %>% 
      dplyr::select(
        symbol, logFC, logCPM, PValue, FDR, DE, everything()  
      ) %>% 
   		as_tibble()
      
  }, simplify = FALSE)	

topTables_glm %>% 
	bind_rows() %>% 
	ggplot(aes(logFC, -log10(PValue))) +
	geom_point(aes(colour = DE)) +
	geom_label_repel(aes(label = symbol), 
									 data = . %>% 
									 	dplyr::filter(DE == T) %>% 
									 	dplyr::slice(1:20)) +
	facet_wrap(~coef, scales = "free_x") +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw() +
	theme(legend.position = "bottom")

```

```{r, fig.cap="*MD plot for psen2^N140fs/+^ samples and psen2^T141_L142delinsMISLISV/+^ compared to psen2^+/+^ samples*"}
topTables_glm %>% 
	bind_rows() %>% 
	ggplot(aes(logCPM, logFC)) +
	geom_point(aes(colour = DE)) +
	geom_label_repel(aes(label = symbol), 
									 data = . %>% 
									 	dplyr::filter(DE == T), 
									 size = 3, alpha = 0.5) +
	facet_wrap(~coef, ncol = 1) +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw()
```

I want to check for a GC or length bias for differential expression. If such a bias is observed, I can correct for it using `cqn`. GC and length information is easily available from `EnsDb` objects from release 98 onwards, so this release was used. No expressed genes were noted as absent from the annotations for Release 98, despite the differences between releases. GC content and Length were taken as weighted averages and simple averages respectively. No discernible bias is observed, supporting that gene set testing can be performed in this dataset. 

```{r}
ens98 <- ah[["AH74989"]]

genes98 <- genes(ens98)

ex <- exonsBy(ens98, "tx")

tr <- transcripts(ens98)

tr$len <- ex %>%
	width %>%
	lapply(sum) %>%
	.[names(tr)] %>%
	unlist()

gnBias <- mcols(tr) %>%
	as.data.frame() %>%
	group_by(gene_id) %>%
	summarise(
		n = n(),
		meanGC = sum(len*gc_content) / sum(len),
		len = mean(len)
	)

mcols(genes) %<>%
	as.data.frame() %>%
	left_join(gnBias) %>%
	DataFrame()

gnGC <- genes %>% 
	mcols() %>% 
	as_tibble() %>% 
	unchop(entrezid) 
```

```{r}
topTables_glm %>% 
	lapply(function(x) {
		x %>% 
			left_join(gnGC) %>% 
			as_tibble()
	}) %>% 
	bind_rows() %>% 
	ggplot(aes(meanGC, sign(logFC)*-log10(PValue))) +
	geom_point(aes(colour = DE)) +
	geom_smooth(se = F) +
	facet_wrap(~coef, ncol = 1) +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw()

topTables_glm %>% 
	lapply(function(x) {
		x %>% 
			left_join(gnGC) %>% 
			as_tibble()
	}) %>% 
	bind_rows() %>% 
	ggplot(aes(len, sign(logFC)*-log10(PValue))) +
	geom_point(aes(colour = DE)) +
	geom_smooth(se = F) +
	geom_hline(yintercept = 0, linetype = 2) +
	scale_x_log10() +
	facet_wrap(~coef, ncol = 1) +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw()
```

# ~~ Enrichment analysis ~~

Here, I will perform enichment analysis both within the DE genes using `goseq`, which allows for a covariate to be a predictor variable, and then within ranked lists using `fry` (which handles inter-gene correlations better than other methods such as GSEA). The gene sets which will be used are the KEGG and GO gene sets from `MSigDB`, and the IRE gene sets which were previously defined by Nhi from our lab which contains genes wich contain an iron-responsive element in the untranslated regions. 

the KEGG and GO gene sets were imported using the `msigdbr` package. The GO terms were only included if they had 3 or more steps back to the ontology root terms. The ire gene sets were provided by Nhi as an `.rds` object which was directly imported. 

## import the gene sets
```{r}
ens2Entrez <- genes %>% 
	as_tibble() %>% 
	dplyr::select(symbol, entrezid) %>% 
	unchop(entrezid) %>% 
	dplyr::filter(symbol %in% rownames(dge)) %>% 
	dplyr::filter(!is.na(entrezid))

KEGG <-
	msigdbr("Danio rerio", category = "C2", subcategory = "CP:KEGG") %>%
	dplyr::rename(entrezid = entrez_gene) %>% 
	inner_join(ens2Entrez) %>%
	distinct(gs_name, symbol, .keep_all = TRUE) %>% 
  split(f = .$gs_name) %>%
  lapply(extract2, "symbol")

# obtained the IRE gene sets from Nhi
ireGenes <- readRDS(here("R/zebrafishIreGenes.rds")) %>% 
 	lapply(function(x){
 		x %>% 
 			as.data.frame() %>% 
 			set_colnames("gene_id") %>% 
 			as_tibble() %>% 
 			left_join(genes %>% 
 									as_tibble() %>% 
 									dplyr::select(gene_id, symbol)) %>% 
 			.$symbol
 	})

# GO terms
goSummaries <- url("https://uofabioinformaticshub.github.io/summaries2GO/data/goSummaries.RDS") %>%
  readRDS() %>%
  mutate(
    Term = Term(id),
    gs_name = Term %>% str_to_upper() %>% str_replace_all("[ -]", "_"),
    gs_name = paste0("GO_", gs_name)
    )
minPath <- 3

go <- msigdbr("Danio rerio", category = "C5") %>% 
	dplyr::rename(entrezid = entrez_gene) %>% 
	inner_join(ens2Entrez) %>%
	distinct(gs_name, symbol, .keep_all = TRUE) %>% 
	split(f = .$gs_name) %>%
	lapply(extract2, "symbol")
```



## Enrichment testing within the DE gene sets: goseq

To test within the DE genes for over-representation of these gene sets, I will use goseq. goseq quantifies the probability of a gene being considered as DE based on a single covariate and corrects for it by estimatting a probability weight function (PWF). Here, I will use the average transcript length per gene. Very minimal over-representation is obsevred in both lists of DE genes for each mutation. 

```{r}
pwfs <- topTables_glm %>%
		lapply(function(x) {
		x %>% 
			left_join(gnGC, by = "symbol") %>% 
			as_tibble() %>% 
				distinct(symbol, .keep_all = TRUE)
	}) %>% 
	lapply(function(x) {
		x %>% 
			with(
				nullp(
					DEgenes = structure(DE, names = symbol), 
					bias.data = len
				)
			)
	})

goseq(pwfs$FS, gene2cat = c(KEGG, go, ireGenes)) %>% 
	as_tibble() %>% 
	mutate(FDR = p.adjust(over_represented_pvalue, method = "fdr")) %>% 
	head(5) %>% 
	dplyr::select(-under_represented_pvalue) %>% 
	kable(caption = "KEGG, GO and IRE gene sets approaching being over-represented in the DE list for the FS mutation") %>% 
	kable_styling()

goseq(pwfs$FAD, gene2cat = c(KEGG,go, ireGenes)) %>% 
	as_tibble() %>% 
	mutate(FDR = p.adjust(over_represented_pvalue, method = "fdr")) %>% 
	head(5) %>% 
	dplyr::select(-under_represented_pvalue) %>% 
	kable(caption = "KEGG, GO and IRE gene sets approaching being over-represented in the DE list for the FAD mutation") %>% 
	kable_styling()
```


# Gene set testing on ranked lists (fry)

To obtain a more complete view on the changes to gene expression due to each mutation, I will use `fry` from the `limma` package, which can take into account inter-gene correlations. Due to the highly overlapping nature of GO terms, I will only look at the ire and KEGG gene sets. 

Using fry, only genes inolved in the Notch signalling pathway is found to be alered in by the FS mutation. 
```{r}
fryRes <- design %>% colnames() %>% .[2:3] %>% 
  sapply(function(x) {
    cpm(dge$counts, log = TRUE) %>% 
    fry(
      index = c(KEGG, ireGenes),
      design = design, 
      contrast = x, 
      sort = "mixed"
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR.Mixed < 0.05)
  }, simplify = FALSE) 

fryRes$FS %>% 
	head(5) %>% 
	kable(caption = "Top 5 most sig altered gene sets found using fry due to heterozygosity for the psen2 N140fs mutation" ) %>% 
	kable_styling()

fryRes$FAD %>% 
	head(5) %>% 
	kable(caption = "Top 5 most sig altered gene sets found using fry due to heterozygosity for the psen2 FAD-like mutation" ) %>% 
	kable_styling()
```

# ~~ RUVSeq to assist with identification of significant gene sets ~~

Since very little conclusions were found about the FAD like mutation, I will use `RUVseq` to see whether I can detect more differential expression of genes/gene sets. I will use the RUVg method, which uses negative control genes. In this case, it will be the least 10,000 DE genes from the initial differential expression due to *psen2* genotype.

```{r}
RUVneg <- 
  dge %>% 
  estimateDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef = 2:3) %>% # use both psen2 genotype coefs
  topTags(n = Inf, adjust.method = "fdr", sort.by = "p") %>% 
  .$table %>% 
	as.data.frame() %>% 
	rownames_to_column("symbol") %>% 
	arrange(desc(PValue)) %>% 
	.[1:10000, ] %>% 
	.$symbol

```

```{r}
### Perform the RUVg method with 1 factor of unwanted variation removed, 
RUV_k1 <- dge$counts %>% 
  round %>% 
  RUVg(RUVneg, 1)
```

### PCA

A PCA analysis was performed on the RUVSeq normalised counts. Not enough of the total variance was explained by PC1 + PC2. However, some seperation between the FS samples was observed.

```{r}
pca_RUV_k1 <- RUV_k1$normalizedCounts %>% 
  as.data.frame() %>% 
	cpm(log = T) %>% 
	t() %>% 
	prcomp()

pca_RUV_k1 %>% 
  autoplot(
    data = tibble(Sample = rownames(.$x)) %>%
      left_join(dge$samples),
    colour = "Genotype_forPub", 
    size = 4, 
    shape = "Sex"
  ) +
  geom_label_repel(
    aes(label = Sample, colour = Genotype_forPub),
    show.legend = FALSE
  ) +
	scale_colour_manual(values = c("grey30", "firebrick", "darkcyan" )) +
	theme(aspect.ratio = 1) +
	labs(colour = "Genotype")
	#ggsave("plots/PCA_RUV.png", width = 10, height = 10, units = "cm", dpi = 600)
```

### MDS

The MDS plot shows that the FS samples also seperate from the others. 

```{r}
RUV_k1$normalizedCounts %>% 
	cpm(log=T) %>% 
	plotMDS(plot = FALSE) %>%
	extract2("cmdscale.out") %>%
	set_colnames(paste0("Dimension ", 1:2)) %>% 
	as.data.frame() %>% 
	rownames_to_column("Sample") %>% 
	left_join(dge$samples) %>% 
	ggplot(aes(`Dimension 1`, `Dimension 2`)) +
	geom_point(aes(colour = Genotype_forPub, shape = Sex), size = 4) +
	scale_colour_manual(values = c("grey50", "firebrick", "darkcyan" )) +
	geom_label_repel(aes(label = Sample, colour = Genotype_forPub), show.legend = FALSE) +
	theme(aspect.ratio = 1) +
	labs(colour = "Genotype")
```

### Hierarchical clustering

```{r}
RUV_k1$normalizedCounts %>% 
  cpm(log = T) %>% 
  t() %>% 
  dist(method = "euclidean") %>% 
  as.matrix() %>% 
  pheatmap(
    color = viridis::viridis_pal(option = "viridis")(100), 
    annotation_col = anno, 
        annotation_colors = list(Genotype = c(FS = "firebrick", 
    																			WT = "grey30", 
    																			EOfAD = "darkcyan")),
    show_rownames = F, show_colnames = F, 
    annotation_row = anno, 
    cellwidth = 10, cellheight = 10, 
    treeheight_row = 5, treeheight_col = 5)
```


# DE analysis with RUVSeq

I next will perform an additional DGE analysis including the `W_1` covariate generated by RUVSeq in the design matrix. 

```{r}
dge$samples %<>% 
	cbind(RUV_k1$W)

# model matrix
design_RUV <- model.matrix(~Genotype + W_1, data = dge$samples)%>% 
	set_colnames(gsub("Genotype", "", colnames(.)))

# fit the glm
fit_RUV <- dge %>% 
	estimateDisp(design_RUV) %>% 
	glmFit(design_RUV)

topTables_glm_RUV <- design_RUV %>% colnames() %>% .[2:3] %>% 
   sapply(function(x){
    glmLRT(fit_RUV, coef = x) %>%
      topTags(n = Inf) %>%
      .[["table"]] %>%
      as.data.frame() %>%
   		rownames_to_column("symbol") %>% 
      arrange(PValue) %>%
       mutate(
        coef = x,
        DE = FDR < 0.05
      ) %>% 
      dplyr::select(
        symbol, logFC, logCPM, PValue, FDR, DE, everything()  
      ) %>% 
   		as_tibble()
      
  }, simplify = FALSE)	

topTables_glm_RUV %>% 
	bind_rows() %>% 
	ggplot(aes(logFC, -log10(PValue))) +
	geom_point(aes(colour = DE)) +
	facet_wrap(~coef, scales = "free_x") +
	# geom_label_repel(aes(label = symbol), 
	# 								 data = . %>% 
	# 								 	dplyr::filter(DE == T) %>% 
	# 								 	dplyr::slice(1:20)) +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw() +
	theme(legend.position = "bottom")

```

```{r, fig.cap="*MD plot for psen2^N140fs/+^ samples and psen2^T141_L142delinsMISLISV/+^ compared to psen2^+/+^ samples*"}
topTables_glm %>% 
	bind_rows() %>% 
	ggplot(aes(logCPM, logFC)) +
	geom_point(aes(colour = DE)) +
	geom_label_repel(aes(label = symbol), 
									 data = . %>% 
									 	dplyr::filter(DE == T), 
									 size = 3, alpha = 0.5) +
	facet_wrap(~coef, ncol = 1) +
	scale_colour_manual(values = c("grey50", "red")) +
	theme_bw()
```

# ~~ Enrichment analysis with RUVSeq ~~# 

## Within DE lists: goseq

The goseq analysis was repeated. However, no over-representation was observed. The top 5 gene sets in each genotype are shown in the tables below. 

```{r}
pwfs_RUV <- topTables_glm_RUV %>%
		lapply(function(x) {
		x %>% 
			left_join(gnGC, by = "symbol") %>% 
			as_tibble() %>% 
				distinct(symbol, .keep_all = TRUE)
	}) %>% 
	lapply(function(x) {
		x %>% 
			with(
				nullp(
					DEgenes = structure(DE, names = symbol), 
					bias.data = len
				)
			)
	})

goseq(pwfs_RUV$FS, gene2cat = c(KEGG, ireGenes, go)) %>% 
	as_tibble() %>% 
	mutate(FDR = p.adjust(over_represented_pvalue, method = "fdr")) %>% 
	head(5) %>% 
	dplyr::select(-under_represented_pvalue) %>% 
	kable(caption = "KEGG, GO and IRE gene sets approaching being over-represented in the DE list for the FS mutation") %>% 
	kable_styling()

goseq(pwfs_RUV$FAD, gene2cat = c(KEGG, ireGenes, go)) %>% 
	as_tibble() %>% 
	mutate(FDR = p.adjust(over_represented_pvalue, method = "fdr")) %>% 
	arrange(numDEInCat) %>% 
	head(5) %>% 
	dplyr::select(-under_represented_pvalue) %>% 
	kable(caption = "KEGG, GO and IRE gene sets approaching being over-represented in the DE list for the FS mutation") %>% 
	kable_styling()
```


# All genes: fry

I next will repeat `fry` to look within the entire list of genes detectable in the experiemnt. 

```{r}
fryRes_RUVk1 <- design %>% colnames() %>% .[2:3] %>% 
  sapply(function(x) {
	    cpm(dge, log = TRUE) %>% 
    fry(
      index = c(KEGG, ireGenes),
      design = design_RUV, 
      contrast = x, 
      sort = "mixed"
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR.Mixed < 0.05)
  }, simplify = FALSE) 

fryRes_RUVk1 %>% 
	bind_rows() %>% 
	dplyr::filter(sig == TRUE) %>% 
	dplyr::select(pathway, NGenes, Direction, PValue.Mixed, FDR.Mixed, coef) %>% 
	kable(caption = "Gene sets showing significant changes to expression as a group using fry, at an FDR of 5%") %>% 
	kable_styling()
```

## harmonic mean-p value of fry, camera and fgsea

Since only few gene sets are observed to be altered by the FAD-like mutation, I will perform a gene set testing method inspired by the EGSEA method, which performs multiple gene set testing algorithms (here, I will use `fry`, `camera` and `fgsea`), then combine the resulting p-values by calculating the harmonic mean p-value. The HMP does push the average towards smaller p-values. However, it does not produce any smaller p-values that already exist from each of the individual test. It is robust to dependent tests (which in this case, it is), and is thought to be less restrictive than other methods. 

```{r}
cameraRes_RUVk1 <- design %>% colnames() %>% .[2:3] %>% 
  sapply(function(x) {
	    cpm(dge, log = TRUE) %>% 
    camera(
      index = c(KEGG, ireGenes),
      design = design_RUV, 
      contrast = x, 
      inter.gene.cor = NA
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x)
  }, simplify = FALSE) 

ranks <- topTables_glm_RUV %>% 
	lapply(function(x) { x %>% 
			mutate(rankstat = sign(logFC)*-log10(PValue)) %>% 
			arrange(desc(rankstat)) %>% 
			dplyr::select(c("symbol", "rankstat")) %>% 
			with(structure(rankstat, names = symbol))
	}) 

# set a seed for a reproducible result. 
set.seed(1)
fgsea_RUVk1 <- ranks %>% 
	sapply(function(x) {
		fgseaMultilevel(stats = x, pathways = c(KEGG, ireGenes))}, 
		simplify = FALSE)

fgsea_RUVk1$FS %<>% 
	mutate(coef = "FS")

fgsea_RUVk1$FAD %<>% 
	mutate(coef = "FAD")

HMP <- fryRes_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::select(pathway, PValue.Mixed, coef) %>% 
  dplyr::rename(fry_p = PValue.Mixed) %>% 
  left_join(cameraRes_RUVk1 %>% 
              bind_rows() %>% 
              dplyr::select(pathway, PValue, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(camera_p = PValue) %>% 
  left_join(fgsea_RUVk1 %>% 
              bind_rows() %>% 
              dplyr::select(pathway, pval, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(fgsea_p = pval) %>% 
  bind_rows() %>% 
  nest(p = one_of(c("fry_p", "camera_p", "fgsea_p"))) %>% 
  mutate(
    harmonic_p = vapply(p, function(x){
      x <- unlist(x)
      x <- x[!is.na(x)]
      p.hmp(x, L = 3)
    }, numeric(1))
  ) %>% 
  unnest() %>% 
  mutate(harmonic_p_FDR = p.adjust(harmonic_p, "fdr"), 
         sig = harmonic_p_FDR < 0.05) %>% 
  arrange(harmonic_p_FDR)

sigpaths <- HMP %>% 
	dplyr::filter(sig == TRUE) %>% 
	.$pathway

HMP %>% 
	dplyr::filter(pathway %in% sigpaths) %>% 
	ggplot(aes(coef, pathway, size =-log10(harmonic_p))) +
	geom_point(aes(colour = sig)) +
	geom_text(
    aes(label = harmonic_p_FDR %>% signif(1)), 
    size = 2.5, 
    vjust = 2.5
  ) +
  labs(colour = "harmonic mean p < 0.05 \nafter FDR adjustment")+
  ggpubr::theme_pubclean()+
  theme(legend.position = "right")+
  scale_color_manual(values = c("grey30", "turquoise3")) 

nums <- HMP %>% 
	dplyr::select(pathway, coef, harmonic_p_FDR) %>% 
	dplyr::filter(pathway %in% sigpaths) %>% 
	mutate(num = case_when(
		harmonic_p_FDR < 0.05 ~ paste(harmonic_p_FDR %>% signif(2)),
		TRUE ~ "ns"
	)) %>% 
	dplyr::select(pathway, coef, num) %>% 
	spread(key = "coef", value = "num") %>% 
	column_to_rownames("pathway") %>% 
	t()


HMP %>% 
	dplyr::select(pathway, coef, harmonic_p_FDR) %>% 
	dplyr::filter(pathway %in% sigpaths) %>% 
	mutate(harmonic_p_FDR = -log10(harmonic_p_FDR)) %>% 
	spread(key = "coef", value = "harmonic_p_FDR") %>% 
	column_to_rownames("pathway") %>% 
	t() %>% 
	pheatmap(color = viridis_pal(option = "magma")(100), 
					 treeheight_row = 0, treeheight_col = 0, 
					 cellwidth = 30, clustering_method = "median", 
					 cellheight = 30, 
					 display_numbers = nums, 
					 #angle_col = 45,
					 number_color = "white")

```

Using the HMP method of combining p-values for GSEA, `r nrow(dplyr::filter(HMP, sig == TRUE & coef == "FAD"))` gene sets significantly altered by the FAD mutation, and `r nrow(dplyr::filter(HMP, sig == TRUE & coef == "FS"))` gene sets significantly altered by the FS mutation. 
The ribosome gene set is altered by both mutations. However, it is much more significant in the FAD. The AD gene set is only significant in the FAD. 

No ire gene sets were found to be significantly altered. However, out of all the ire gene sets, the ire3_all was the most significantly altered in the FAD. 

```{r}
HMP %>% 
	dplyr::filter(pathway %>% grepl(pathway, pattern = "ire")) %>% 
	dplyr::select(-c(fry_p, fgsea_p, camera_p)) %>% 
	kable(caption = "harmonic mean p-value of IRE gene sets") %>% 
	kable_styling()
```


## exploration of gene sets

### Upset plots of leading edge genes. 

The plots below show that the signals for the sig gene sets are mostly independent of one another. (As shown by the leading edge genes, which can be thought of as the core genes which drive the enrichment of the gene set. )

```{r}
fgsea_RUVk1$FS %>% 
	dplyr::filter(pathway %in% c(HMP %>% 
															 	dplyr::filter(coef == "FS") %>% 
															 	dplyr::filter(sig == TRUE) %>% .$pathway)) %>% 
	dplyr::select(pathway, leadingEdge) %>% 
	mutate(pathway = str_remove(pathway, "KEGG_"), 
				 pathway = str_replace(pathway, 
				 											pattern = "TRANSENDOTHELIAL_MIGRATION", 
				 											replacement = "TRANSENDO_MIGR...")) %>% 
	unnest %>% 
	split(f = .$pathway) %>% 
	lapply(magrittr::extract2,"leadingEdge") %>% 
	fromList() %>% 
	upset(order.by = "freq", 
				nsets = length(.), 
				mb.ratio = c(0.5, 0.5)
				)
```


```{r}
fgsea_RUVk1$FAD %>% 
	dplyr::filter(pathway %in% c(HMP %>% 
															 	dplyr::filter(coef == "FAD") %>% 
															 	dplyr::filter(sig == TRUE) %>% .$pathway)) %>% 
	dplyr::select(pathway, leadingEdge) %>% 
	mutate(pathway = str_remove(pathway, "KEGG_")) %>% 
	unnest %>% 
	split(f = .$pathway) %>% 
	lapply(magrittr::extract2,"leadingEdge") %>% 
	fromList() %>% 
	upset(order.by = "freq", nsets = length(.), 
				mb.ratio = c(0.5, 0.5))
```

### pheatmaps of logFCs

```{r}
topTables_glm_RUV %>% 
	bind_rows() %>% 
	dplyr::filter(symbol %in% KEGG$KEGG_RIBOSOME) %>% 
	dplyr::select(symbol, logFC, coef) %>% 
	spread(key = "coef", value = "logFC") %>%
	column_to_rownames("symbol") %>% 
	pheatmap(
		color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
  breaks = c(
  	seq(min(.), 0, length.out=ceiling(100/2) + 1), 
  	seq(max(.)/100, max(.), length.out=floor(100/2))
  	), 
  treeheight_row = 0, treeheight_col = 0,
  main = "KEGG_RIBOSOME"
	)

topTables_glm_RUV %>% 
	bind_rows() %>% 
	dplyr::filter(symbol %in% KEGG$KEGG_OXIDATIVE_PHOSPHORYLATION) %>% 
	dplyr::select(symbol, logFC, coef) %>% 
	spread(key = "coef", value = "logFC") %>%
	column_to_rownames("symbol") %>% 
	pheatmap(color = colorRampPalette(rev(brewer.pal(n = 7, name =
  "RdBu")))(100),
  treeheight_row = 0, 
  main = "KEGG_OXIDATIVE_PHOSPHORYLATION",
  treeheight_col = 0,
  breaks = c(
  	seq(min(.), 0, length.out=ceiling(100/2) + 1), 
  	seq(max(.)/100, max(.), length.out=floor(100/2))
  	)
	)
```

# session info
```{r}
sessionInfo() %>% 
	pander()
```

